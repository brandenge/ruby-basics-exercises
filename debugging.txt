    *** 1 - Reading Error Messages ***

Problem: You come across the following code. What errors does it raise for the given examples and what exactly do the error messages mean?

def find_first_nonzero_among(numbers)
  numbers.each do |n|
    return n if n.nonzero?
  end
end

find_first_nonzero_among(0, 0, 1, 0, 2, 0)
find_first_nonzero_among(1)

Solution:

NoMethodError - You are trying to use #each in the method body, which is an instance method for the Array or Enumerable classes, but provide only integers as arguments in the method call. The Integer or Numeric classes do not have an instance method called #each, hence the NoMethodError.

Also ArgumentError - The method is expecting 1 argument, but the first method call provides 6 arguments.

The fix:

find_first_nonzero_among([0, 0, 1, 0, 2, 0])
find_first_nonzero_among([1])

    *** 2 - Weather Forecast ***

Problem: Our predict_weather method should output a message indicating whether a sunny or cloudy day lies ahead. However, the output is the same every time the method is invoked. Why? Fix the code so that it behaves as expected.

def predict_weather
  sunshine = ['true', 'false'].sample

  if sunshine
    puts "Today's weather will be sunny!"
  else
    puts "Today's weather will be cloudy!"
  end
end

Solution:

The problem is on the line with the if statement. It is essentially saying "if the sunshine variable exists.." which will always evaluate to true, because it does exist. It needs to compare sunshine to to one of its possible strings that it is being sampled from.

Note that this problem would not exist if the array being sampled for the variable sunshine contained the boolean values true or false. It is because they are stored as strings in the array. So either change the values in the array to boolean values, or if keeping them as strings, then you must use the comparison operator with the if statement, or else it will always evaluate as a truthy value.

def predict_weather
  sunshine = [true, false].sample

  if sunshine
    puts "Today's weather will be sunny!"
  else
    puts "Today's weather will be cloudy!"
  end
end

predict_weather

    *** 3 - Multiply By Five ***

Problem: When the user inputs 10, we expect the program to print The result is 50!, but that's not the output we see. Why not?

def multiply_by_five(n)
  n * 5
end

puts "Hello! Which number would you like to multiply by 5?"
number = gets.chomp

puts "The result is #{multiply_by_five(number)}!"

Solution:

We need to convert the input from a string to an integer to be able to perform math operations on it. All user input comes as a string by default, including numbers.

def multiply_by_five(n)
  n * 5
end

puts "Hello! Which number would you like to multiply by 5?"
number = gets.chomp.to_i

puts "The result is #{multiply_by_five(number)}!"

    *** 4 - Pets ***

Problem: Magdalena has just adopted a new pet! She wants to add her new dog, Bowser, to the pets hash. After doing so, she realizes that her dogs Sparky and Fido have been mistakenly removed. Help Magdalena fix her code so that all three of her dogs' names will be associated with the key :dog in the pets hash.

pets = { cat: 'fluffy', dog: ['sparky', 'fido'], fish: 'oscar' }

pets[:dog] = 'bowser'

p pets #=> {:cat=>"fluffy", :dog=>"bowser", :fish=>"oscar"}

Solution:

pets = { cat: 'fluffy', dog: ['sparky', 'fido'], fish: 'oscar' }
pets[:dog] << 'bowser'
p pets

    *** 5 - Even Numbers ***

Problem: We want to iterate through the numbers array and return a new array containing only the even numbers. However, our code isn't producing the expected output. Why not? How can we change it to produce the expected result?

numbers = [5, 2, 9, 6, 3, 1, 8]

even_numbers = numbers.map do |n|
  n if n.even?
end

p even_numbers # expected output: [2, 6, 8]

Solution:

The code is returning nil upon each iteration that does not enter the conditional statement, which would be every time it encounters an odd number. The reason for this is that the block for the #map method will always return a value for every iteration, even if that value is nil.

To fix, we need to use a different method - use #select or #filter instead of #map. This will not return any value for any iteration the boolean expression inside of the block evaluates as false.

numbers = [5, 2, 9, 6, 3, 1, 8]
even_numbers = numbers.select { |n| n.even? }
p even_numbers

numbers = [5, 2, 9, 6, 3, 1, 8]
even_numbers = numbers.filter { |n| n.even? }
p even_numbers

    *** 6 - Confucius Says ***

Problem: You want to have a small script delivering motivational quotes, but with the following code you run into a very common error message: no implicit conversion of nil into String (TypeError). What is the problem and how can you fix it?

def get_quote(person)
  if person == 'Yoda'
    'Do. Or do not. There is no try.'
  end

  if person == 'Confucius'
    'I hear and I forget. I see and I remember. I do and I understand.'
  end

  if person == 'Einstein'
    'Do not worry about your difficulties in Mathematics. I can assure you mine are still greater.'
  end
end

puts 'Confucius says:'
puts '"' + get_quote('Confucius') + '"'

Solution:

What is happening here is that there is no explicit return statement, so the method will always implicitly return the last evaluated expression. In this case, when #get_quote is invoked with the argument 'Yoda' or 'Confucius', it will enter a conditional statement with a string. But because that is not the last statement in the method body, it will then exit from the conditional statement (doing nothing with the string that it evaluated inside of the conditional), and then continue evaluating the body of the method. In this case, the last expression to be evaluated in the method body is:

if person == 'Einstein'

So for any argument that was not equal to 'Einstein', this statement will return nil, and then nil is what gets returned from the method.

Note that the only way the code works as it is, is if you invoked the method with the argument 'Einstein' instead, because then the string inside of the conditional statement for person == 'Einstein' will be the last statement evaluated, and will be implicitly returned correctly.

So to fix this, we simply need to add explicit return statements to the strings inside of the conditional statements. Or you need to combine all of these separate if statements into one single if statement, using elsif and else. You could also use a case statement.

def get_quote(person)
  if person == 'Yoda'
    return 'Do. Or do not. There is no try.'
  end

  if person == 'Confucius'
    return 'I hear and I forget. I see and I remember. I do and I understand.'
  end

  if person == 'Einstein'
    return 'Do not worry about your difficulties in Mathematics. I can assure you mine are still greater.'
  end
end

puts 'Confucius says:'
puts '"' + get_quote('Confucius') + '"'

def get_quote(person)
  if person == 'Yoda'
    'Do. Or do not. There is no try.'
  elsif person == 'Confucius'
    'I hear and I forget. I see and I remember. I do and I understand.'
  elsif person == 'Einstein'
    'Do not worry about your difficulties in Mathematics. I can assure you mine are still greater.'
  end
end

puts 'Confucius says:'
puts '"' + get_quote('Confucius') + '"'

def get_quote(person)
  case person
  when 'Yoda'
    'Do. Or do not. There is no try.'
  when 'Confucius'
    'I hear and I forget. I see and I remember. I do and I understand.'
  when 'Einstein'
    'Do not worry about your difficulties in Mathematics. I can assure you mine are still greater.'
  end
end

puts 'Confucius says:'
puts "\"#{get_quote('Confucius')}\""

    *** 7 - Account Balance ***

Problem: Time for a check of your financial situation.

The output of the code below tells you that you have around $70. However, you expected your bank account to have about $238. What did we do wrong?

# Financially, you started the year with a clean slate.

balance = 0

# Here's what you earned and spent during the first three months.

january = {
  income: [ 1200, 75 ],
  expenses: [ 650, 140, 33.2, 100, 26.9, 78 ]
}

february = {
  income: [ 1200 ],
  expenses: [ 650, 140, 320, 46.7, 122.5 ]
}

march = {
  income: [ 1200, 10, 75 ],
  expenses: [ 650, 140, 350, 12, 59.9, 2.5 ]
}

# Let's see how much you've got now...

def calculate_balance(month)
  plus  = month[:income].sum
  minus = month[:expenses].sum

  plus - minus
end

[january, february, march].each do |month|
  balance = calculate_balance(month)
end

puts balance

Solution:

You forgot to add += when assigning the balance variable. So what is happening is you are re-assigning balance everytime you iterate to calculate each month, resulting in only saving the last month's balance. What we want to do is increment balance by adding the balance of every month for each iteration to the variable balance, which would result in the balance of all the months.

balance = 0

january = {
  income: [ 1200, 75 ],
  expenses: [ 650, 140, 33.2, 100, 26.9, 78 ]
}

february = {
  income: [ 1200 ],
  expenses: [ 650, 140, 320, 46.7, 122.5 ]
}

march = {
  income: [ 1200, 10, 75 ],
  expenses: [ 650, 140, 350, 12, 59.9, 2.5 ]
}

def calculate_balance(month)
  plus  = month[:income].sum
  minus = month[:expenses].sum

  plus - minus
end

[january, february, march].each do |month|
  balance += calculate_balance(month)
end

puts balance

    *** 8 - Colorful Things ***

Problem: The following code throws an error. Find out what is wrong and think about how you would fix it.

colors = ['red', 'yellow', 'purple', 'green', 'dark blue', 'turquoise', 'silver', 'black']
things = ['pen', 'mouse pad', 'coffee mug', 'sofa', 'surf board', 'training mat', 'notebook']

colors.shuffle!
things.shuffle!

i = 0
loop do
  break if i > colors.length

  if i == 0
    puts 'I have a ' + colors[i] + ' ' + things[i] + '.'
  else
    puts 'And a ' + colors[i] + ' ' + things[i] + '.'
  end

  i += 1
end

Solution:

colors = ['red', 'yellow', 'purple', 'green', 'dark blue', 'turquoise', 'silver', 'black']
things = ['pen', 'mouse pad', 'coffee mug', 'sofa', 'surf board', 'training mat', 'notebook']

colors.shuffle!
things.shuffle!

i = 0
loop do
  if i == 0
    puts 'I have a ' + colors[i] + ' ' + things[i] + '.'
  else
    puts 'And a ' + colors[i] + ' ' + things[i] + '.'
  end
  break if i == [things.length, colors.length].min - 1
  i += 1
end

    *** 9 - Digit Product ***

Problem: Given a String of digits, our digit_product method should return the product of all digits in the String argument. You've been asked to implement this method without using reduce or inject.

When testing the method, you are surprised by a return value of 0. What's wrong with this code and how can you fix it?

def digit_product(str_num)
  digits = str_num.chars.map { |n| n.to_i }
  product = 0

  digits.each do |digit|
    product *= digit
  end

  product
end

p digit_product('12345')
# expected return value: 120
# actual return value: 0

Solution:

def digit_product(str_num)
  digits = str_num.chars.map { |n| n.to_i }
  product = 1

  digits.each do |digit|
    product *= digit
  end

  product
end

p digit_product('12345')

    *** 10 - Warriors and Wizards ***

Problem: We started writing an RPG game, but we already run into an error message. Find the problem and fix it.

# Each player starts with the same basic stats.

player = { strength: 10, dexterity: 10, charisma: 10, stamina: 10 }

# Then the player picks a character class and gets an upgrade accordingly.

player = { strength: 10, dexterity: 10, charisma: 10, stamina: 10 }

character_classes = {
  warrior: { strength:  20 },
  thief:   { dexterity: 20 },
  scout:   { stamina:   20 },
  mage:    { charisma:  20 }
}

puts 'Please type your class (warrior, thief, scout, mage):'
input = gets.chomp.downcase

player.merge(character_classes[input])

puts 'Your character stats:'
puts player

Solution:

You have to convert the input from a string to a symbol to be able to reference it using bracket notation. Otherwise the string key will not match the keys in the hash, which are symbols, and thus it will return nil since it is a key that does not currently exist, and all hash keys that don't exist return nil by default. When it returns nil, it feeds nil as the argument into the #merge method, which is expecting a hash, hence the TypeError of no implicit conversion of nil into hash.

You also need to use #merge! instead of #merge, or save the results of #merge because otherwise it is returning a modified version of player, and so those modifications will not be output from the last line using #puts.

player = { strength: 10, dexterity: 10, charisma: 10, stamina: 10 }

character_classes = {
  warrior: { strength:  20 },
  thief:   { dexterity: 20 },
  scout:   { stamina:   20 },
  mage:    { charisma:  20 }
}

puts 'Please type your class (warrior, thief, scout, mage):'
input = gets.chomp.downcase

player.merge!(character_classes[input.to_sym])

puts 'Your character stats:'
puts player

Example of #merge! with a block:

player = { strength: 10, dexterity: 10, charisma: 10, stamina: 10 }

character_classes = {
  warrior: { strength:  20 },
  thief:   { dexterity: 20 },
  scout:   { stamina:   20 },
  mage:    { charisma:  20 }
}

puts 'Please type your class (warrior, thief, scout, mage):'
input = gets.chomp.downcase

player.merge!(character_classes[input.to_sym]) do |key, old_value, new_value|
  old_value + new_value
end

puts 'Your character stats:'
puts player
