    *** 1 - Create a String ***

Problem: Create an empty string using the String class and assign it to a variable.

Solution: str = String.new

    *** 2 - Quote Confusion ***

Problem: Modify the following code so that double-quotes are used instead of single-quotes.

puts 'It\'s now 12 o\'clock.'

Expected output:

It's now 12 o'clock.

Solution:

puts "It's now 12 o'clock."

puts %Q(It's now 12 o'clock.)

puts %!It's now 12 o'clock.!

What about strings that contain double- and single-quotes? How would you write those using the alternate syntax?

You can also use just about any symbol with percent strings, such as:

puts %!It's now 12 o'clock.!

In this example, ! is used in place of quotation marks to mark the start and end of the string. You could use just about any other symbol in its place as well, such as @, #, $, %, ^, &, *, etc. Also note that these symbols when used with percent strings are all equivalent to double quotes, not single quotes.

This is useful if you are using a lot of double quotes, single quotes, and perhaps even other symbols in the string and you want to avoid conflicts.

    *** 3 - Ignoring Case ***

Problem: Using the following code, compare the value of name with the string 'RoGeR' while ignoring the case of both strings. Print true if the values are the same; print false if they aren't. Then, perform the same case-insensitive comparison, except compare the value of name with the string 'DAVE' instead of 'RoGeR'.

name = 'Roger'

Expected output:

true
false

Solution:

name = 'Roger'
puts name.casecmp?('RoGeR')
puts name.casecmp?('DAVE')

    *** 4 - Dynamic String ***

Problem: Modify the following code so that the value of name is printed within "Hello, !".

name = 'Elizabeth'

puts "Hello, !"

Expected output:

Hello, Elizabeth!

Solution:

name = 'Elizabeth'
puts "Hello, #{name}!"

    *** 5 - Combining Names ***

Problem: Using the following code, combine the two names together to form a full name and assign that value to a variable named full_name. Then, print the value of full_name.

first_name = 'John'
last_name = 'Doe'

Expected output:

John Doe

Solution:

first_name = 'John'
last_name = 'Doe'
puts full_name = "#{first_name} #{last_name}"

first_name = 'John'
last_name = 'Doe'
puts full_name = [first_name, last_name].join(' ')

Further Exploration:

Can you think of at least two additional ways to combine a first and last name into a full name?

String interpolation, the #concat method, and also the Array#join method, such as: puts full_name = [first_name, last_name].join(' ')

    *** 6 - Tricky Formatting ***

Problem: Using the following code, capitalize the value of state then print the modified value. Note that state should have the modified value both before and after you print it.

state = 'tExAs'

Expected output:

Texas

Solution:

state = 'tExAs'
puts state.capitalize!

    *** 7 - Goodbye, not Hello ***

Problem: Given the following code, invoke a destructive method on greeting so that Goodbye! is printed instead of Hello!.

greeting = 'Hello!'
puts greeting

Expected output:

Goodbye!

Solution:

greeting = 'Hello!'
puts greeting.replace('Goodbye!')

greeting = 'Hello!'
puts greeting.gsub!('Hello', 'Goodbye')

greeting = 'Hello!'
puts greeting.clear << "Goodbye!"

    *** 8 - Print the Alphabet ***

Problem: Using the following code, split the value of alphabet by individual characters and print each character.

alphabet = 'abcdefghijklmnopqrstuvwxyz'

Expected output:

a
b
c
d
e
f
g
h
i
j
k
l
m
n
o
p
q
r
s
t
u
v
w
x
y
z

Solution:

alphabet = 'abcdefghijklmnopqrstuvwxyz'
alphabet.each_char { |char| puts char }

alphabet = 'abcdefghijklmnopqrstuvwxyz'
puts alphabet.split('')

alphabet = 'abcdefghijklmnopqrstuvwxyz'
alphabet.chars.each {|c| puts c }

alphabet = 'abcdefghijklmnopqrstuvwxyz'
puts alphabet.split(//)

The above example is using an empty regular expression with //

alphabet = 'abcdefghijklmnopqrstuvwxyz'
alphabet.split(%r{\s*}).each {|item| puts item }

I don't know what %r{\s*} in the above means. It looks like another syntax for a regular expression possibly. %r{ } is the same as // maybe? And matches to any single character \s meaning single maybe, and * meaning any.

    *** 9 - Pluralize ***

Problem: Given the following code, use Array#each to print the plural of each word in words.

words = 'car human elephant airplane'

Expected output:

cars
humans
elephants
airplanes

Solution:

words = 'car human elephant airplane'
words.split(' ').each { |word| puts word + 's'}

    *** 10 - Are You There? ***

Problem: Using the following code, print true if colors includes the color 'yellow' and print false if it doesn't. Then, print true if colors includes the color 'purple' and print false if it doesn't.

colors = 'blue pink yellow orange'

Expected output:

true
false

Solution:

colors = 'blue pink yellow orange'
puts colors.include?('yellow')
puts colors.include?('purple')

colors = 'blue pink yellow orange'
p /yellow/.match?(colors)
p /purple/.match?(colors)

Further exploration:

Let's say colors is changed to the following value:

colors = 'blue boredom yellow'

and we invoke #include? as we did before:

puts colors.include?('red')

What will the output be? Why?

colors = 'blue boredom yellow'
puts colors.include?('red')

The output then is true because the substring 'red' exists inside of the word 'boredom'.
